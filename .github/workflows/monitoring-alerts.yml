name: Monitoring and Alerts
on:
  schedule:
    - cron: '*/15 * * * *'  # Every 15 minutes
  workflow_run:
    workflows: ["CI Failure Handler", "Infinite Loop Prevention"]
    types: [completed]

jobs:
  system-monitoring:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: System Health Check
        id: health_check
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Check automation block status
            const isBlocked = fs.existsSync('.automation-blocked');
            let blockInfo = null;
            
            if (isBlocked) {
              try {
                blockInfo = JSON.parse(fs.readFileSync('.automation-blocked', 'utf8'));
              } catch (e) {
                blockInfo = { reason: 'Unknown', timestamp: 'Unknown' };
              }
            }
            
            // Check recent issues for problems
            const { data: recentIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'system-alert,urgent,human-fix-needed',
              per_page: 10
            });
            
            // Check workflow failures
            const now = new Date();
            const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
            
            const { data: workflowRuns } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              created: `>${oneHourAgo.toISOString()}`,
              status: 'completed',
              conclusion: 'failure',
              per_page: 10
            });
            
            // Calculate health score
            let healthScore = 100;
            let alerts = [];
            
            if (isBlocked) {
              healthScore -= 50;
              alerts.push({
                level: 'critical',
                message: `Automation blocked: ${blockInfo.reason}`,
                timestamp: blockInfo.timestamp
              });
            }
            
            if (recentIssues.length > 0) {
              healthScore -= (recentIssues.length * 10);
              alerts.push({
                level: 'warning',
                message: `${recentIssues.length} urgent issues requiring attention`,
                issues: recentIssues.map(i => `#${i.number}: ${i.title}`)
              });
            }
            
            if (workflowRuns.total_count > 5) {
              healthScore -= 20;
              alerts.push({
                level: 'warning',
                message: `High workflow failure rate: ${workflowRuns.total_count} failures in last hour`
              });
            }
            
            healthScore = Math.max(0, healthScore);
            
            const systemStatus = {
              health_score: healthScore,
              status: healthScore >= 90 ? 'healthy' : healthScore >= 70 ? 'warning' : 'critical',
              automation_blocked: isBlocked,
              urgent_issues: recentIssues.length,
              recent_failures: workflowRuns.total_count,
              alerts: alerts,
              last_check: now.toISOString()
            };
            
            core.setOutput('system_status', JSON.stringify(systemStatus));
            core.setOutput('health_score', healthScore);
            core.setOutput('status_level', systemStatus.status);
            
            return systemStatus;
            
      - name: Update System Status Badge
        uses: actions/github-script@v7
        with:
          script: |
            const statusInfo = JSON.parse('${{ steps.health_check.outputs.system_status }}');
            const score = statusInfo.health_score;
            const status = statusInfo.status;
            
            // Determine badge color
            const colorMap = {
              'healthy': 'brightgreen',
              'warning': 'yellow', 
              'critical': 'red'
            };
            
            const color = colorMap[status] || 'lightgrey';
            const badgeUrl = `https://img.shields.io/badge/System%20Health-${score}%25-${color}`;
            
            // Update README if it exists
            try {
              const { data: readme } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'README.md'
              });
              
              let content = Buffer.from(readme.content, 'base64').toString();
              const healthBadge = `![System Health](${badgeUrl})`;
              
              // Replace existing health badge or add new one
              const healthBadgeRegex = /!\[System Health\].*$/m;
              if (healthBadgeRegex.test(content)) {
                content = content.replace(healthBadgeRegex, healthBadge);
              } else {
                // Add after progress badge if it exists
                const progressBadgeRegex = /(!\[Progress\].*$)/m;
                if (progressBadgeRegex.test(content)) {
                  content = content.replace(progressBadgeRegex, `$1 ${healthBadge}`);
                } else {
                  content = `${healthBadge}\n\n${content}`;
                }
              }
              
              await github.rest.repos.createOrUpdateFileContents({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'README.md',
                message: `ğŸ“Š Update system health badge: ${score}%`,
                content: Buffer.from(content).toString('base64'),
                sha: readme.sha
              });
            } catch (error) {
              console.log('Could not update README:', error.message);
            }
            
      - name: Send Critical Alerts
        if: steps.health_check.outputs.status_level == 'critical'
        uses: actions/github-script@v7
        with:
          script: |
            const statusInfo = JSON.parse('${{ steps.health_check.outputs.system_status }}');
            
            // Create critical alert issue
            const alertBody = `
# ğŸš¨ ì‹œìŠ¤í…œ ì‹¬ê° ê²½ê³ 

**ì‹œê°„**: ${statusInfo.last_check}  
**ìƒíƒœ**: CRITICAL (${statusInfo.health_score}%)

## ğŸ” ê°ì§€ëœ ë¬¸ì œë“¤

${statusInfo.alerts.map(alert => {
  let alertText = `### ${alert.level.toUpperCase()}: ${alert.message}`;
  if (alert.timestamp) alertText += `\n**ì‹œê°„**: ${alert.timestamp}`;
  if (alert.issues) alertText += `\n**ê´€ë ¨ ì´ìŠˆë“¤**:\n${alert.issues.map(i => `- ${i}`).join('\n')}`;
  return alertText;
}).join('\n\n')}

## ğŸ“‹ ê¶Œì¥ ì¡°ì¹˜

1. ğŸ” [ì—ëŸ¬ í•¸ë“¤ë§ ê°€ì´ë“œ](./docs/error-handling.md) ì°¸ì¡°
2. ğŸ¥ ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬ ì‹¤í–‰: \`./scripts/health-check.sh --verbose\`
3. ğŸš« í•„ìš”ì‹œ ê¸´ê¸‰ ì¤‘ë‹¨: \`echo '{"reason":"manual_stop"}' > .automation-blocked\`

## ğŸ“Š ì‹œìŠ¤í…œ ìƒíƒœ

- **ìë™í™” ì°¨ë‹¨**: ${statusInfo.automation_blocked ? 'ğŸš« ì˜ˆ' : 'âœ… ì•„ë‹ˆìš”'}
- **ê¸´ê¸‰ ì´ìŠˆ**: ${statusInfo.urgent_issues}ê°œ
- **ìµœê·¼ ì‹¤íŒ¨**: ${statusInfo.recent_failures}íšŒ (ì§€ë‚œ 1ì‹œê°„)

---
*ğŸ¤– ìë™ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ*
            `;
            
            // Check if similar alert exists in last 2 hours
            const twoHoursAgo = new Date(Date.now() - 2 * 60 * 60 * 1000);
            const { data: recentAlerts } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'system-alert,critical-alert',
              since: twoHoursAgo.toISOString(),
              state: 'open'
            });
            
            // Only create new alert if no recent similar one exists
            if (recentAlerts.length === 0) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `ğŸš¨ CRITICAL: System Health at ${statusInfo.health_score}%`,
                body: alertBody,
                labels: ['system-alert', 'critical-alert', 'urgent']
              });
            }
            
      - name: Update Monitoring Dashboard
        uses: actions/github-script@v7
        with:
          script: |
            const statusInfo = JSON.parse('${{ steps.health_check.outputs.system_status }}');
            
            // Read current monitoring data
            let monitoringHistory = [];
            try {
              const { data: file } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'docs/monitoring-history.json'
              });
              monitoringHistory = JSON.parse(Buffer.from(file.content, 'base64').toString());
            } catch (error) {
              // File doesn't exist, start fresh
            }
            
            // Add current status to history
            monitoringHistory.push({
              timestamp: statusInfo.last_check,
              health_score: statusInfo.health_score,
              status: statusInfo.status,
              automation_blocked: statusInfo.automation_blocked,
              urgent_issues: statusInfo.urgent_issues,
              recent_failures: statusInfo.recent_failures
            });
            
            // Keep only last 7 days of data (96 entries per day at 15-min intervals)
            const maxEntries = 96 * 7;
            if (monitoringHistory.length > maxEntries) {
              monitoringHistory = monitoringHistory.slice(-maxEntries);
            }
            
            // Update monitoring history file
            let existingSha;
            try {
              const { data: existing } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'docs/monitoring-history.json'
              });
              existingSha = existing.sha;
            } catch (error) {
              // File doesn't exist
            }
            
            await github.rest.repos.createOrUpdateFileContents({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: 'docs/monitoring-history.json',
              message: 'ğŸ“Š Update monitoring history',
              content: Buffer.from(JSON.stringify(monitoringHistory, null, 2)).toString('base64'),
              sha: existingSha
            });
            
            // Generate monitoring report
            const now = new Date();
            const last24h = monitoringHistory.filter(entry => 
              new Date(entry.timestamp) > new Date(now.getTime() - 24 * 60 * 60 * 1000)
            );
            
            const avgScore24h = last24h.length > 0 ? 
              Math.round(last24h.reduce((sum, entry) => sum + entry.health_score, 0) / last24h.length) : 0;
            
            const downtimeCount = last24h.filter(entry => entry.automation_blocked).length;
            const downtimePercentage = last24h.length > 0 ? 
              Math.round((downtimeCount / last24h.length) * 100) : 0;
            
            const monitoringReport = `# ğŸ“Š ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ë¦¬í¬íŠ¸
            
**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: ${statusInfo.last_check}
            
## ğŸ¯ í˜„ì¬ ìƒíƒœ
            
- **ì‹œìŠ¤í…œ ìƒíƒœ**: ${statusInfo.status.toUpperCase()} (${statusInfo.health_score}%)
- **ìë™í™”**: ${statusInfo.automation_blocked ? 'ğŸš« ì°¨ë‹¨ë¨' : 'âœ… ì •ìƒ'}
- **ê¸´ê¸‰ ì´ìŠˆ**: ${statusInfo.urgent_issues}ê°œ
- **ìµœê·¼ ì‹¤íŒ¨**: ${statusInfo.recent_failures}íšŒ
            
## ğŸ“ˆ 24ì‹œê°„ í†µê³„
            
- **í‰ê·  ìƒíƒœ ì ìˆ˜**: ${avgScore24h}%
- **ë‹¤ìš´íƒ€ì„**: ${downtimePercentage}% (${downtimeCount}/${last24h.length} ì²´í¬)
- **ì²´í¬ íšŸìˆ˜**: ${last24h.length}íšŒ
            
## âš ï¸ í˜„ì¬ ì•Œë¦¼
            
${statusInfo.alerts.length > 0 ? 
  statusInfo.alerts.map(alert => `- **${alert.level.toUpperCase()}**: ${alert.message}`).join('\n') :
  'âœ… í™œì„± ì•Œë¦¼ ì—†ìŒ'
}
            
## ğŸ“Š ìƒíƒœ ì¶”ì´ (ìµœê·¼ 24ì‹œê°„)
            
| ì‹œê°„ | ìƒíƒœ ì ìˆ˜ | ìƒíƒœ | ì°¨ë‹¨ | ì´ìŠˆ | ì‹¤íŒ¨ |
|------|-----------|------|------|------|------|
${last24h.slice(-10).reverse().map(entry => {
  const time = new Date(entry.timestamp).toLocaleTimeString();
  const statusEmoji = entry.status === 'healthy' ? 'âœ…' : entry.status === 'warning' ? 'âš ï¸' : 'ğŸš¨';
  return `| ${time} | ${entry.health_score}% | ${statusEmoji} ${entry.status} | ${entry.automation_blocked ? 'ğŸš«' : 'âœ…'} | ${entry.urgent_issues} | ${entry.recent_failures} |`;
}).join('\n')}
            
---
*ìë™ ìƒì„±ë¨ - 15ë¶„ë§ˆë‹¤ ì—…ë°ì´íŠ¸*
            `;
            
            // Update monitoring report
            let reportSha;
            try {
              const { data: report } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'docs/monitoring-report.md'
              });
              reportSha = report.sha;
            } catch (error) {
              // File doesn't exist
            }
            
            await github.rest.repos.createOrUpdateFileContents({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: 'docs/monitoring-report.md',
              message: 'ğŸ“Š Update monitoring report',
              content: Buffer.from(monitoringReport).toString('base64'),
              sha: reportSha
            });
