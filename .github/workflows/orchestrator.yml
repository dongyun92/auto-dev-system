name: ðŸ¤– Orchestrator - Auto Issue Generation

on:
  push:
    paths:
      - 'spec/**'
      - '!spec/README.md'
      - '!spec/modules/README.md'
  workflow_dispatch:
    inputs:
      force_regenerate:
        description: 'Force regenerate all issues'
        required: false
        default: 'false'

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  parse-and-generate:
    runs-on: ubuntu-latest
    name: Parse YAML and Generate Issues
    
    steps:
    - name: ðŸ“¥ Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: ðŸ” Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: ðŸ“‹ Install YAML Parser
      run: |
        npm install js-yaml
        
    - name: ðŸ” Check for existing issues
      id: check_issues
      run: |
        # GitHub CLIë¥¼ ì‚¬ìš©í•´ì„œ ê¸°ì¡´ ì´ìŠˆ í™•ì¸
        existing_issues=$(gh issue list --label "auto-generated" --state open --json number,title --jq '. | length')
        echo "existing_count=$existing_issues" >> $GITHUB_OUTPUT
        echo "Found $existing_issues existing auto-generated issues"
      env:
        GH_TOKEN: ${{ github.token }}
        
    - name: ðŸ“„ Parse YAML and Generate Issues
      id: parse_yaml
      run: |
        node << 'EOF'
        const fs = require('fs');
        const yaml = require('js-yaml');
        const path = require('path');
        
        // spec.yaml ì½ê¸°
        const specPath = 'spec/spec.yaml';
        let projectSpec = {};
        if (fs.existsSync(specPath)) {
          projectSpec = yaml.load(fs.readFileSync(specPath, 'utf8'));
        }
        
        // modules í´ë”ì—ì„œ YAML íŒŒì¼ë“¤ ì°¾ê¸°
        const modulesDir = 'spec/modules';
        const moduleFiles = [];
        
        if (fs.existsSync(modulesDir)) {
          const files = fs.readdirSync(modulesDir);
          files.forEach(file => {
            if (file.endsWith('.yaml') || file.endsWith('.yml')) {
              const filePath = path.join(modulesDir, file);
              try {
                const moduleSpec = yaml.load(fs.readFileSync(filePath, 'utf8'));
                if (moduleSpec && moduleSpec.name) {
                  moduleFiles.push({
                    file: file,
                    spec: moduleSpec
                  });
                }
              } catch (e) {
                console.log(`Warning: Failed to parse ${file}: ${e.message}`);
              }
            }
          });
        }
        
        console.log(`Found ${moduleFiles.length} module specifications`);
        
        // ì˜ì¡´ì„± ìˆœì„œ ê³„ì‚° (ê°„ë‹¨í•œ í† í´ë¡œì§€ ì •ë ¬)
        function resolveDependencies(modules) {
          const resolved = [];
          const remaining = [...modules];
          
          while (remaining.length > 0) {
            const canResolve = remaining.filter(module => {
              const deps = module.spec.depends_on || [];
              return deps.every(dep => resolved.some(r => r.spec.name === dep));
            });
            
            if (canResolve.length === 0) {
              // ìˆœí™˜ ì˜ì¡´ì„± ë˜ëŠ” ìž˜ëª»ëœ ì˜ì¡´ì„±
              console.log('Warning: Circular dependency detected or invalid dependency');
              remaining.forEach(module => resolved.push(module));
              break;
            }
            
            canResolve.forEach(module => {
              resolved.push(module);
              const index = remaining.indexOf(module);
              remaining.splice(index, 1);
            });
          }
          
          return resolved;
        }
        
        const orderedModules = resolveDependencies(moduleFiles);
        
        // GitHub Issues ìƒì„±ì„ ìœ„í•œ ë°ì´í„° ì¤€ë¹„
        const phases = projectSpec.development_phases || [
          { name: 'implementation', description: 'ê¸°ë³¸ ê¸°ëŠ¥ êµ¬í˜„', labels: ['dev', 'implementation'] },
          { name: 'testing', description: 'ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ë° í†µí•© í…ŒìŠ¤íŠ¸', labels: ['test', 'quality'] },
          { name: 'integration', description: 'ëª¨ë“ˆ ê°„ í†µí•© ë° API ì—°ê²°', labels: ['integration', 'api'] }
        ];
        
        const issuesData = [];
        let issueNumber = 1;
        
        orderedModules.forEach((module, moduleIndex) => {
          phases.forEach((phase, phaseIndex) => {
            const issue = {
              title: `[${phase.name.toUpperCase()}] ${module.spec.name} - ${phase.description}`,
              body: generateIssueBody(module.spec, phase, projectSpec),
              labels: ['auto-generated', 'claude-task', ...phase.labels],
              assignees: [],
              moduleIndex,
              phaseIndex,
              moduleName: module.spec.name,
              phaseName: phase.name
            };
            issuesData.push(issue);
            issueNumber++;
          });
        });
        
        function generateIssueBody(moduleSpec, phase, projectSpec) {
          let body = `# ${moduleSpec.name} - ${phase.description}\n\n`;
          body += `## ðŸ“‹ ëª¨ë“ˆ ì •ë³´\n`;
          body += `- **ì´ë¦„**: ${moduleSpec.name}\n`;
          body += `- **ì„¤ëª…**: ${moduleSpec.description || 'N/A'}\n`;
          body += `- **ë²„ì „**: ${moduleSpec.version || '1.0.0'}\n`;
          
          if (moduleSpec.depends_on && moduleSpec.depends_on.length > 0) {
            body += `- **ì˜ì¡´ì„±**: ${moduleSpec.depends_on.join(', ')}\n`;
          }
          
          body += `\n## ðŸŽ¯ ${phase.description}\n\n`;
          
          if (phase.name === 'implementation') {
            body += `### êµ¬í˜„ ìš”êµ¬ì‚¬í•­\n`;
            if (moduleSpec.endpoints) {
              body += `#### API ì—”ë“œí¬ì¸íŠ¸\n`;
              moduleSpec.endpoints.forEach(endpoint => {
                body += `- \`${endpoint.method} ${endpoint.path}\`: ${endpoint.description}\n`;
              });
            }
            if (moduleSpec.tech_stack) {
              body += `\n#### ê¸°ìˆ  ìŠ¤íƒ\n`;
              moduleSpec.tech_stack.forEach(tech => {
                body += `- ${tech}\n`;
              });
            }
          } else if (phase.name === 'testing') {
            body += `### í…ŒìŠ¤íŠ¸ ìš”êµ¬ì‚¬í•­\n`;
            if (moduleSpec.tests) {
              if (moduleSpec.tests.unit_test_coverage) {
                body += `- **ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€**: ${moduleSpec.tests.unit_test_coverage}%\n`;
              }
              if (moduleSpec.tests.integration_tests) {
                body += `- **í†µí•© í…ŒìŠ¤íŠ¸**: í•„ìˆ˜\n`;
              }
            }
          } else if (phase.name === 'integration') {
            body += `### í†µí•© ìš”êµ¬ì‚¬í•­\n`;
            body += `- API ë¬¸ì„œ ìƒì„±\n`;
            body += `- ë‹¤ë¥¸ ëª¨ë“ˆê³¼ì˜ ì—°ë™ í…ŒìŠ¤íŠ¸\n`;
            if (moduleSpec.depends_on) {
              body += `- ì˜ì¡´ ëª¨ë“ˆê³¼ì˜ ì¸í„°íŽ˜ì´ìŠ¤ ê²€ì¦\n`;
            }
          }
          
          body += `\n## âœ… ì™„ë£Œ ì¡°ê±´\n`;
          body += `- [ ] ê¸°ëŠ¥ êµ¬í˜„ ì™„ë£Œ\n`;
          body += `- [ ] ì½”ë“œ ë¦¬ë·° í†µê³¼\n`;
          body += `- [ ] í…ŒìŠ¤íŠ¸ í†µê³¼\n`;
          body += `- [ ] ë¬¸ì„œí™” ì™„ë£Œ\n`;
          
          body += `\n---\n`;
          body += `*ðŸ¤– ì´ ì´ìŠˆëŠ” ìžë™ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. @claude ë¥¼ ë©˜ì…˜í•˜ì—¬ ê°œë°œì„ ì‹œìž‘í•˜ì„¸ìš”.*\n`;
          
          return body;
        }
        
        // ê²°ê³¼ë¥¼ íŒŒì¼ë¡œ ì €ìž¥
        fs.writeFileSync('issues.json', JSON.stringify(issuesData, null, 2));
        console.log(`Generated ${issuesData.length} issues for ${orderedModules.length} modules`);
        
        // GitHub Actions ì¶œë ¥
        console.log(`::set-output name=issues_count::${issuesData.length}`);
        console.log(`::set-output name=modules_count::${orderedModules.length}`);
        EOF
        
    - name: ðŸŽ¯ Create GitHub Issues
      if: steps.check_issues.outputs.existing_count == '0' || github.event.inputs.force_regenerate == 'true'
      run: |
        # issues.json íŒŒì¼ì—ì„œ ì´ìŠˆ ë°ì´í„° ì½ê¸°
        if [ ! -f "issues.json" ]; then
          echo "No issues.json file found"
          exit 0
        fi
        
        # jqë¥¼ ì‚¬ìš©í•´ì„œ JSON íŒŒì‹±í•˜ê³  ì´ìŠˆ ìƒì„±
        issue_count=$(jq '. | length' issues.json)
        echo "Creating $issue_count issues..."
        
        for i in $(seq 0 $((issue_count - 1))); do
          title=$(jq -r ".[$i].title" issues.json)
          body=$(jq -r ".[$i].body" issues.json)
          labels=$(jq -r ".[$i].labels | join(\",\")" issues.json)
          
          echo "Creating issue: $title"
          
          gh issue create \
            --title "$title" \
            --body "$body" \
            --label "$labels" \
            --assignee "" || echo "Failed to create issue: $title"
            
          # API ë ˆì´íŠ¸ ë¦¬ë°‹ ë°©ì§€ë¥¼ ìœ„í•œ ëŒ€ê¸°
          sleep 2
        done
        
        echo "âœ… Issue creation completed"
        
      env:
        GH_TOKEN: ${{ github.token }}
        
    - name: ðŸ“Š Summary
      run: |
        echo "## ðŸŽ‰ Orchestrator Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“‹ Generated Issues" >> $GITHUB_STEP_SUMMARY
        echo "- **Total Issues**: ${{ steps.parse_yaml.outputs.issues_count }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Modules**: ${{ steps.parse_yaml.outputs.modules_count }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”„ Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "1. Claude Code will automatically pick up these issues" >> $GITHUB_STEP_SUMMARY
        echo "2. Development will proceed in dependency order" >> $GITHUB_STEP_SUMMARY
        echo "3. Each module goes through: Implementation â†’ Testing â†’ Integration" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ðŸ¤– **Auto-development pipeline is now active!**" >> $GITHUB_STEP_SUMMARY
